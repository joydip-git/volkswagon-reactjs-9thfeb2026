React JS:
------------
a JS library which helps to create a SPA which runs at the front-end (client-side)
the react app is collection of components

to create React JS app:
--------------------------
build tools: vite and create-react-app (deprecated)
frameworks: Next JS, Gatsby, React Router, Redwood etc.

React Component:
-------------------------
a function that returns a react element

JSX
-----------
JavaScript and XML => the syntax used by React JS to design the React component UI
in this syntax ONLY ONE root React element is possible, just like XML, where only one root element is possible in the entire XML document. Hence the name.

the data and event handlers (functions) are attached with any element by "binding" using {} syntax

comments in JSX: {/* */}


Virtual DOM
---------------
a tree of React elements created by React JS app
this VDOM is translated into HTML DOM by render() method of the Root element of React JS. 
every time the React app is run, the whole React App design is rendered in the UI this way, known as mounting phase

Hydration:
------------
when the React app starts initially the HTML page is rendered in the browser without any React component design. the HTML page is said to be "dehydrated" at that point. in the meantime the code in the main.jsx/.tsx file starts getting executed and a moment later the complete React app design is rendered in the placeholder HTML element (<div id='root'></div>). the HTML page is said to be "hydrated" at that moment. this whole process is known as "hydration"

How the UI is updated?
----------------------
if the data in any component changes React creates a fresh version of VDOM for that component by re-calling the component.
then using "diffing" algorithm React compares the previous VDOM and new VDOM and tracks the changes in the respective components and simply updates the corresponding HTML DOM elements, rather than mounting the whole HTML DOM again.

the component can be called by React runtime over again if...
1. the state of data (to be tracked) is maintained for a component by using useState() method
this method creates a storage for this component and stores the default value that you passed to the useState() method
the method returns an array with 2 index position.
in the 1st index: the copy of the data is stored
in the 2nd index: a reference to a function (to update that data) is stored

in order to update the component UI
	1. first update the state of the component by calling the "set" function (to update the state at the 2nd index)
	2. this will cause the React to call the component once more and pass the copy of the updated data from the state

Note: the "set" method is asynchronous. it does not block the thread and hence you will proceed to next line of code immediately whereas the state of the component is being updated parallely

a type of state depends on what value you want to save in it. it can be string , number, Boolean, object etc.
there can be more than one state for a component and each can be of different types
state should be mutated immutably
state is a component's intrinsic property/asset. the state of a component can not be shared with any other component


function useState<T>(initial:T){
	let data = initial
	
	function update(newData:T){
		data = newData
	}

	function update(callback:(oldState:T) => T){
		let newData = callback(data)
		data = newData
	}

	return [data, update]
}

const [title, setTitle] = useState('welcome...')

setTitle('VDOM')


Binding:
-------------
1. data binding: flow of data is from code to the UI of the component
2. event binding: flow of data is from the UI of the component to the code of the component


StrictMode => It is a built-in React Component.
Lets you find common bugs in your components early during development

atomicity:
------------------
1. state-full component: a component where you maintain state of data
2. stateless component: a component where you don't maintain any state, rather the component receives data from its parent and simply displays it. also known as presentational component.

nested component:
-------------------
a component nested inside another component as a child

design pattern: lifting the state up
-----------------------------------------
1. treat one component (statefull) a source of data
2. pass down the parent state data to the children
3. if any child updates the state data in parent the whole parent VDOM tree (includes the children) is re-rendered. as a result all the children gets the same updated data


how to pass parent component data and handler functions to any child component???
---------------------------------------------------------------------------------
via props or property object
React JS allows to you pass data and handler functions via some attributes (in JSX) of the component
behind the scence React JS creates an object, known as property object, with those attributes as properties in that objecr along with data and passes that property object to the function component as an argument
the property object is read-only. don't modify the property values. that will crash the app. the data that has been passed from parent to child should be displayed as it is to maintain consistency.



how to pass data from child component back to its parent component:
--------------------------------------------------------------------
via event binding
pass a handler function from parent component to the child component through some property of child component and then call the handler function from some event of the child component design element and pass data the through that function

how to render a collection?
-------------------------------------
displaying a an array/list of React Elements
every child in the list of react elements, MUST/SHOULD have an unique key (built-in property of every React Element) property value, just to improve performance
if the list is altered and the component re-renders, the key property will help React JS diffing algo to track the changes/differences btn two VDOMs (previous and new) very easily
key property value NO only should be unique, it should be fixed (does not change every time the React element re-renders)
Note: do not use index position of the element in the array as key property value. it is an anti-pattern.
key property should be used with the root element in the design 

rfc
rfce
rafc
rafce




